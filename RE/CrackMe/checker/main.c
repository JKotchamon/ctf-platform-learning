#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <openssl/aes.h>
#include "target.h"  // generated by gen_target (contains TARGET and TARGET_LEN)

// Simple PKCS#7 pad to 16-byte blocks
static void pkcs7_pad(uint8_t *buf, size_t *len, size_t cap) {
    size_t pad = 16 - (*len % 16);
    if (pad == 0) pad = 16;
    if (*len + pad > cap) return;
    for (size_t i = 0; i < pad; i++) buf[*len + i] = (uint8_t)pad;
    *len += pad;
}

int main(void) {
    // NOTE for contributors:
    // The AES key used for TARGET generation lives only in gen_target.c.
    // The runtime checker uses the same key here for consistency.
    // For learning purposes we keep it plain. You can obfuscate later.

    static const uint8_t KEY[16] = {
        0x13,0x37,0xC0,0xDE,0x42,0x21,0x69,0x00,
        0xAA,0x55,0x44,0x33,0x22,0x11,0xFE,0xED
    };

    char input[128];
    printf("Enter flag: ");
    if (!fgets(input, sizeof(input), stdin)) return 1;

    size_t n = strcspn(input, "\r\n");
    input[n] = '\0';

    uint8_t buf[128] = {0};
    memcpy(buf, input, n);
    size_t len = n;
    pkcs7_pad(buf, &len, sizeof(buf));

    if (len != TARGET_LEN) {
        puts("❌ Try again.");
        return 1;
    }

    AES_KEY aes;
    AES_set_encrypt_key(KEY, 128, &aes);

    uint8_t out[128] = {0};
    for (size_t i = 0; i < len; i += 16) {
        AES_ecb_encrypt(buf + i, out + i, &aes, AES_ENCRYPT);
    }

    if (memcmp(out, TARGET, TARGET_LEN) == 0) {
        puts("✅ Correct!");
        return 0;
    } else {
        puts("❌ Try again.");
        return 1;
    }
}
